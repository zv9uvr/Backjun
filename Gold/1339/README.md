# 🚩 Algorithm Study: Greedy Algorithm

## [BOJ 1339] 단어 수학 (Python)

본 프로젝트는 주어진 알파벳 단어들의 합을 최대로 만들기 위해 각 문자에 최적의 숫자(0-9)를 할당하는 그리디 알고리즘을 구현했습니다.


### 1. 문제 개요

* **핵심 개념**: Greedy Algorithm, 가중치 분석
* **문제 설명**: 개의 단어가 주어질 때, 각 알파벳을 숫자로 바꿔서 얻을 수 있는 합의 최댓값을 구함
* **제약 조건**: 서로 다른 알파벳은 서로 다른 숫자로 대응되어야 함

### 2. 기술적 분석 및 비판적 검토 (Security & Engineering)

#### **[명세 분석의 오류: Leading Zero 문제]**

현재 코드에는 가중치가 가장 낮은 알파벳이 단어의 시작 숫자인지 체크하여 순서를 바꾸는 로직이 포함되어 있습니다.

* **비판**: 이 문제의 조건에는 **"숫자의 첫 번째 자리에 0이 올 수 없다"는 제약이 존재하지 않습니다.**
* **보안적 관점**: 보안 개발자는 명세(Specification)를 철저히 분석해야 합니다. 존재하지 않는 제약 조건을 위해 복잡한 로직(`deque.rotate` 등)을 추가하는 것은 **코드 복잡성을 불필요하게 증가**시키며, 이는 잠재적인 버그(Attack Surface)를 생성하는 행위입니다. 가급적 단순하고 명확한(KISS: Keep It Simple, Stupid) 로직을 유지해야 합니다.

#### **[데이터 구조 및 가중치 계산 최적화]**

* **가중치 산출**: 각 알파벳이 등장하는 자릿수를  형태로 환산하여 누적 합산하였습니다. 이는 각 문자의 **영향력(Impact Score)**을 수치화하는 가장 효율적인 방법입니다.
* **정렬 전략**: 가중치가 높은 순서대로 9부터 0까지 배정하는 방식은 **Local Optimum이 Global Optimum임을 보장**하는 그리디의 속성을 정확히 활용했습니다.


### 3. 주요 로직 (Implementation)

```python
# 1. 각 알파벳의 자릿수 가중치 계산 (A=100, B=10 등)
for i in range(len(alp)):
    index = ord(alp[i])-65
    weight = len(alp)-i-1
    weight_array[index] += (10**weight)

# 2. 가중치가 높은 순서대로 내림차순 정렬
sorted_params = sorted(params.items(), key=operator.itemgetter(1), reverse=True)

# 3. 큰 가중치부터 9, 8, 7... 할당 (핵심 그리디 로직)

```

### 4. 회고 및 보안 직무적 고찰

* **Efficiency**: 현재  (단어 수  단어 길이)로 매우 효율적이나, 리스트와 딕셔너리를 혼용하여 변환하는 과정에서 메모리 오버헤드가 발생할 수 있습니다.
* **Robustness**: 입력값에 알파벳 외의 특수문자가 들어올 경우 `ord(alp[i])-65`에서 오류가 발생할 수 있습니다. 실무 보안 코딩에서는 **Input Validation**을 통해 예상치 못한 입력에 대한 예외 처리가 필수적입니다.
* **Refactoring**: 불필요한 `deque` 로직을 제거하면 가독성과 성능이 대폭 향상될 것입니다.


**[다음 단계]**
* 불필요한 `missing`, `start_num`, `deque` 관련 로직을 모두 걷어내고, **순수하게 가중치 기반으로만 동작하는 클린 코드**로 리팩토링할 것.
* 그리고 3학년이 되기 전, **'최대 힙(Max Heap)'**을 사용하여 가중치를 관리하도록 코드를 고쳐 자료구조 이해력을 높일 것.
