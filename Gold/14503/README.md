# boj_14503_robot_vacuum
## 문제 개요
- **문제 링크**: [백준 14503번](https://www.acmicpc.net/problem/14503)
- **핵심 요약**: 방의 상태와 로봇 청소기의 처음 위치, 방향이 주어졌을 때, 정해진 규칙에 따라 청소하는 칸의 전체 개수를 구하는 시뮬레이션 문제.
- **주요 조건**
  - **현재 위치 청소**: 현재 칸이 청소되지 않았다면 청소함.
  - **주변 4칸 탐색**: 반시계 방향으로 90도씩 회전하며 청소되지 않은 빈 칸이 있는지 확인.
  - **후진 및 작동 중지**: 4방향 모두 청소되어 있거나 벽인 경우, 바라보는 방향을 유지한 채 한 칸 후진. 뒤쪽이 벽이라 후진할 수 없다면 작동을 멈춤.

## 입출력 예시 (Input&Output)
- Input
```
3 3
1 1 0
1 1 1
1 0 1
1 1 1
```
- Output
```
1
```

## 해결 로직
- **방향 벡터(dr, dc) 활용**: 북(0), 동(1), 남(2), 서(3)를 기준으로 한 좌표 변화량을 리스트로 관리하여 `if`문 지옥을 방지함.
  - `dr = [-1, 0, 1, 0]`, `dc = [0, 1, 0, -1]`
- **상태 관리**: 별도의 `not_clean` 리스트를 관리하는 대신, `room` 배열의 값을 직접 변경(0: 빈칸, 1: 벽, 2: 청소 완료)하여 메모리와 로직의 효율성을 높임.
- **반시계 회전**: `(d + 3) % 4` 수식을 사용하여 현재 방향(`d`)을 기준으로 왼쪽 방향을 계산함.
- **후진 로직**: 현재 좌표에서 방향 벡터를 빼는 방식(`r - dr[d], c - dc[d]`)으로 바라보는 방향을 유지한 채 후진을 구현함.

## 사후 분석 및 배운 점 (Retrospective)
- **자료구조의 적절한 선택**: 처음에는 `not_clean` 리스트를 만들어 관리하려 했으나, 실시간으로 변하는 시뮬레이션에서는 2차원 배열 자체를 상태 저장소로 쓰는 것이 훨씬 직관적이고 버그가 적다는 것을 깨달음.
- **코드 효율화 (Refactoring)**: 수많은 `if` 조건문을 방향 벡터(`dr, dc`)와 반복문으로 교체하며 코드 가독성을 획기적으로 개선함.
- **예외 처리 역량**: `TypeError: 'int' object is not iterable` 에러를 통해 파이썬의 `list()` 생성자가 `iterable`한 객체만을 인자로 받는다는 기본 개념을 확실히 복습함.
