# boj_1132_sum
## 문제 개요
- **문제 링크**: [백준 1132번](https://www.acmicpc.net/problem/1132)
- **핵심 요약**: N개의 단어가 주어질 때, 각 알파벳에 0~9까지의 숫자를 중복 없이 배정하여 전체 합을 최대로 만드는 문제.
- **주요 조건**
  - 모든 알파벳은 서로 다른 숫자에 대응됨.
  - 어떤 수도 0으로 시작할 수 없음. (가장 중요한 예외 처리 포인트!)

## 입출력 예시 (Input&Output)
- Input
```
2
ABC
BCA
```
- Output
```
1875
```

## 해결 로직
- **가중치 계산**: 각 알파벳이 자릿수에 따라 가지는 가중치를 $10^{weight}$ 형태로 누적 계산함.
```예시: ABC인 경우, A: 100, B: 10, C: 1의 가중치를 가짐.```
  - **가중치 저장**: 10개의 알파벳 A~J의 각 가중치를 배열 `weight_array`(`[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`)에 누적으로 저장함.
  이때 각 알파벳의 순서에 따라 index 순서를 지정하여 `index = ord(alp[i])-65  # A=0, B=1, C=2 ...`로 표현함.
- **그리디(Greedy) 적용**: `weight_array`를 기준으로 하여 누적 가중치가 큰 알파벳부터 9, 8, 7... 숫자를 배정함.
- **예외 처리 (Leading Zero)**
  - `deque.rotate()`를 활용하여 '첫 번째 숫자'가 아닌 것 중 가중치가 가장 낮은 알파벳을 찾아 0을 배정함.

## 사후 분석 및 배운 점 (Retrospective)
- **디버깅 경험**: VS Code 디버거를 사용하여 딕셔너리 정렬 결과가 리스트 형태로 반환되는 특성을 파악하고 수정함.
- **외부 라이브러리**: `numpy` 등 외부 모듈 없이 표준 라이브러리만으로 효율적인 로직을 구현하는 법을 익힘.
