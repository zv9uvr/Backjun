# 🚩 Algorithm Study: Dynamic Programming
[BOJ 1932] 정수 삼각형 (Python)
본 프로젝트는 알고리즘 효율성 및 메모리 최적화를 고려하여 작성되었습니다.

## 1. 문제 개요
* 핵심 개념: Dynamic Programming (DP)
* 문제 설명: 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 수의 합이 최대가 되는 경로를 찾는 최적화 문제
* 입력 규모: $N \le 500$ (삼각형의 크기)

## 2. 해결 전략 (Engineering Point)
단순 재귀(Recursive) 방식은 중복 계산으로 인해 $O(2^N)$의 시간 복잡도를 유발하므로, Bottom-Up 방식의 DP를 채택하여 시간 복잡도를 $O(N^2)$으로 최적화했습니다.

**[보안 및 효율성 관점의 코드 리뷰]**
* 메모리 최적화 (Space Complexity): 새로운 2차원 리스트를 생성하지 않고, 입력받은 integer 리스트의 값을 직접 갱신(In-place modification)하여 공간 복잡도를 최적화했습니다. 
이는 대규모 데이터 처리 시 불필요한 메모리 할당(Memory Allocation) 오버헤드를 줄이는 실무적인 접근입니다.
* I/O 최적화: sys.stdin.readline을 활용하여 대량의 입력 데이터 처리 시 발생할 수 있는 병목 현상을 방지했습니다. 보안 시스템에서 로그를 대량으로 분석하거나 실시간 트래픽을 처리할 때 필수적인 습관입니다.

## 3. 주요 로직 (Implementation)
삼각형의 각 위치 $(i, j)$에서 가질 수 있는 최대값은 다음과 같은 점화식을 따릅니다.
### $$DP[i][j] = \max(DP[i-1][j-1], DP[i-1][j]) + CurrentValue$$

Python

```
# 가운데 위치한 요소의 최대 경로 합 계산
# 양 끝(0, i)이 아닌 경우 상단의 두 경로 중 최댓값을 선택하여 누적
else:
    integer[i][j] += max(integer[i-1][j-1], integer[i-1][j])
```

# 4. 회고 및 비판적 분석
* 한계점: 현재 코드는 입력받은 원본 데이터를 수정합니다. 만약 원본 데이터 보존이 필요한 보안 감사 시스템이라면 별도의 메모리 공간이 필요할 수 있습니다.
* 확장성: $N$이 매우 커질 경우를 대비해, 슬라이딩 윈도우(Sliding Window) 기법을 적용하면 공간 복잡도를 $O(N^2)$에서 $O(N)$으로 추가 절감이 가능합니다.
