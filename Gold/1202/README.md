# boj_1202_jewel_thief

### 📌 문제 정보
- **난이도**: Gold 2
- **유형**: 그리디(Greedy), 우선순위 큐(Priority Queue)
- **문제 링크**: [백준 1202번](https://www.acmicpc.net/problem/1202)

### 💡 풀이 아이디어 (알고리즘 원리)
- **그리디 전략**: 각 가방에 담을 수 있는 보석 중 가장 가치가 높은 보석을 선택하는 것이 최적의 해입니다.
- **가방 기준 정렬**: 가방을 무게순으로 오름차순 정렬하여, 작은 가방부터 차례대로 보석을 할당합니다.
- **최대 힙(Max Heap) 활용**: 현재 가방 무게 이하인 모든 보석의 가치를 우선순위 큐(`heapq`)에 넣습니다. 작은 가방에 들어가는 보석은 큰 가방에도 들어갈 수 있다는 성질을 이용하여 큐를 유지하며 효율성을 높였습니다.
- **시간 복잡도**: $O((N+K)\log N)$의 효율성으로 설계하여, 단순 반복문 사용 시 발생하는 $O(N \times K)$의 시간 초과 문제를 해결했습니다.

### 🛠 개발 환경 및 트러블슈팅
- **Language**: Python 3.x
- **IDE**: VS Code (GitHub Web Editor 활용)
- **Trouble Shooting**:
    - 처음에 **이중 for문**으로 접근하여 $O(N \times K)$ 연산(최대 900억 번)으로 인한 **시간 초과**가 발생했으나, 우선순위 큐를 도입하여 해결했습니다.
    - Python의 느린 입력 속도를 극복하기 위해 `sys.stdin.readline`을 사용하여 입출력 효율을 높였습니다.
    - 루프 인덱스(`range(K)`)와 실제 가방 무게 리스트(`Ci`)의 값을 혼동하여 **데이터가 0으로 출력되는 논리 오류**를 디버깅을 통해 수정했습니다.
